       In rezolvarea primului task se urmaresc urmatorii pasi: Comprimarea imaginii folosing algorimul de compresie prezentat, indexarea corecta a arborelui creat, formarea vectorului care stocheaza datele necesare. 
       In implementarea acestui task au fost folosite mai multe tipuri de date neomogene pentru a retine si stoca informatiile despre: Pixeli, arbore si vectorul care va fi format pe baza arborelui. De asemenea, au fost implementate si functii auxiliare.
       Astfel, in algoritmul de compresie este calculata culoarea medie, cu ajutorul careia se va forma “mean”-ul cerut. Acesta este apoi verificat cu factorul. Astfel, se decide daca avem culoare uniforma sau nu in cadranul current. In caz contrar imaginea este “impartita” in 4 noi cadrane pentru care se repeta algoritmul in mod recursive. Ulterior, arborele creat va fi indexat in functia “indexing” print-o parcurgere in latime (BFS), folosind functiile standard ale un cozi: initializare nod/coada, adaugare nod in coada si eliminare nod din coada. In ultima instanta, trebuie sa completam informatiile pentru fiecare element din vector rezultate din arborele creeat. Astfel, in functia “Create_array”, folosim algoritmul de parcurgere in latime si ne copiem informatiile cerute din fiecare nod al arborelui in vector.
       In interiorul main-ului se face citirea fisierului ppm stocand informatiile necesare, alocarea de memorie pentru matricea de pixeli si vector. Ulterior, sunt apelate functiile de compresie si de formare a vectorului. Functia “count” – afla numarul de noduri, iar “count_leaves” – numarul de frunze. Aceste date impreuna cu vectorul format sunt scrie intr-un fisier binar si memoria este eliberata pentru matricea de imagine, vector, nodurile formate si cozi.
       In rezolvarea celui de-al doilea task se realizeaza procesul invers primul task: formarea arborelui dupa vectorul dat si formarea matricei imagine dupa arborele rezultat.
       In functia “Create_tree” se formeaza arborele pornind de la un vector primit ca parametru. Astfel, se introduc informatiile legate de arie si culori si pozitie. Algoritmul trece prin toate elementele si se reapeleaza recursiv. Functia “decompress” formeaza matricea de imagine in functie de arborele primit ca parametru. Astfel, functia verifica daca un nod este frunza(are culoare uniforma), in caz pozitiv introduce datele corespunzatoare, iar in caz contrar functia se reapeleaza recursiv.
       In interiorul main-ul se face citirea fisierului binar, stocandu-se informatiile despre numarul de noduri, frunze si vector. Ulterior, se apeleaza functia de creare a arborelui pe baza vectorului stocat si cea de creare a matricei imagine pe baza arborelui rezultat. In final, se formeaza fisierul ppm cu datele despre imagine si matricea de pixeli. 
       
